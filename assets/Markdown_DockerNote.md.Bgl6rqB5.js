import{_ as t,c as o,o as r,ag as a}from"./chunks/framework.S-Qvb3wi.js";const s="/assets/docker1.CpKlMHiX.png",d="/assets/docker2.Cuhmta_-.png",m=JSON.parse('{"title":"DockerNote","description":"","frontmatter":{"title":"DockerNote"},"headers":[],"relativePath":"Markdown/DockerNote.md","filePath":"Markdown/DockerNote.md"}'),i={name:"Markdown/DockerNote.md"};function c(n,e,l,p,h,k){return r(),o("div",null,e[0]||(e[0]=[a('<h1 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;Docker&quot;">​</a></h1><p><strong>docker安装使用yum需要注意，是docker-ce，<a href="https://blog.csdn.net/weixin_43755251/article/details/127512751?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522e9895de5cc1319c006efe87617395611%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=e9895de5cc1319c006efe87617395611&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127512751-null-null.142%5Ev102%5Epc_search_result_base7&amp;utm_term=Linux%E5%AE%89%E8%A3%85docker&amp;spm=1018.2226.3001.4187" target="_blank" rel="noreferrer">相关教程1</a><a href="https://blog.csdn.net/m0_59196543/article/details/124749175?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522e9895de5cc1319c006efe87617395611%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=e9895de5cc1319c006efe87617395611&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-124749175-null-null.142%5Ev102%5Epc_search_result_base7&amp;utm_term=Linux%E5%AE%89%E8%A3%85docker&amp;spm=1018.2226.3001.4187" target="_blank" rel="noreferrer">相关教程2</a></strong>——————用老版本docker镜像换源怎么换都访问不了，最后发现是版本问题，真的是干裂开了</p><p>步骤1安装依赖utils、device-mapper、lvm2 ；步骤2：切换国内镜像的docker源 ；步骤3：安装docker</p><p>是一个开源的<strong>应用容器</strong>引擎，采用的是cs架构</p><p>优势体现在存储应用程序上，在日志以及数据方面并不擅长</p><p>它启动快的一个重要原因是没有抽象层(跟虚拟机比)同时不需要内核直接依赖宿主机</p><p>平时我们安装进虚拟机的CentOS都是好几个G，<strong>为什么Docker这里才200M</strong> ?</p><p>对于一个精简的OS , rootfs可以很小，只需要包含最基本的命令工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别,因此不同的发行版可以公用bootfs。</p><p>Docker的内核主要部分是rootfs并且其内核并不完整，还经过优化和压缩处理</p><p>Bootfs与rootfs都属于联合文件系统(UnionFS)，有UnionFS实现的overlayFS属于Linux内核(Linux kernel)的一部分</p><p>Docker可以通过yum直接安装——yum -y install docker</p><p><strong>镜像</strong>是一种轻量级的、可执行的独立软件包</p><p>Docker镜像加载采用的是UnionFS（联合文件系统）</p><h2 id="容器技术与虚拟化技术" tabindex="-1">容器技术与虚拟化技术 <a class="header-anchor" href="#容器技术与虚拟化技术" aria-label="Permalink to &quot;容器技术与虚拟化技术&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>技术</strong></th><th><strong>优势</strong></th><th><strong>劣势</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>容器</strong></td><td>轻量、快速启动、高资源利用率、易扩展</td><td>隔离性较弱、依赖宿主机内核</td><td>云原生应用、微服务、CI/CD</td></tr><tr><td><strong>虚拟机</strong></td><td>强隔离性、兼容多操作系统、安全性高</td><td>资源占用大、启动慢、运维复杂</td><td>传统应用、多租户隔离</td></tr></tbody></table><h2 id="数据卷容器技术-容器间共享数据" tabindex="-1">数据卷容器技术：容器间共享数据 <a class="header-anchor" href="#数据卷容器技术-容器间共享数据" aria-label="Permalink to &quot;数据卷容器技术：容器间共享数据&quot;">​</a></h2><p>主要参数--volumes-from(参考java的extend)</p><p>docker的一种备份机制技术，当父容器被删除，保证子容器依旧可以访问，本质是<strong>目录的挂载</strong>，出现的原因是为了防止docker容器删除后，数据也被删除的情况即保存<strong>容器内的数据的需要</strong>，<strong>持久化数据和同步化操作的需要</strong></p><p>关于具名挂载与匿名挂载的区别就在于<strong>是否指定了挂载位置</strong> 主要参数是-v</p><h2 id="dockerfile与docker-commit" tabindex="-1">dockerfile与docker commit <a class="header-anchor" href="#dockerfile与docker-commit" aria-label="Permalink to &quot;dockerfile与docker commit&quot;">​</a></h2><p>Dockerfile 和 docker commit 是两种不同的镜像构建方式</p><p>dockerfile基础用法如图： <img src="'+s+'" alt="" loading="lazy"></p><p>docker commit用法如图：<img src="'+d+'" alt="" loading="lazy"></p><h4 id="两者对比-列表" tabindex="-1"><strong>两者对比(列表)</strong> <a class="header-anchor" href="#两者对比-列表" aria-label="Permalink to &quot;**两者对比(列表)**&quot;">​</a></h4><table tabindex="0"><thead><tr><th><strong>维度</strong></th><th><strong>Dockerfile</strong></th><th><strong>docker commit</strong></th></tr></thead><tbody><tr><td><strong>构建方式</strong></td><td>声明式（代码驱动）</td><td>快照式（手动操作容器后提交）</td></tr><tr><td><strong>可重复性</strong></td><td>✅ 完全一致</td><td>❌ 依赖容器临时状态</td></tr><tr><td><strong>维护性</strong></td><td>✅ 版本可控，易于更新</td><td>❌ 难以维护和复现</td></tr><tr><td><strong>镜像体积</strong></td><td>✅ 优化分层，体积较小</td><td>❌ 可能包含冗余文件，体积较大</td></tr><tr><td><strong>适用场景</strong></td><td>生产环境、自动化流程、团队协作</td><td>临时调试、实验性操作</td></tr><tr><td><strong>学习成本</strong></td><td>较高（需掌握语法）</td><td>低（仅需基础命令）</td></tr></tbody></table><hr><h4 id="相关建议" tabindex="-1"><strong>相关建议</strong> <a class="header-anchor" href="#相关建议" aria-label="Permalink to &quot;**相关建议**&quot;">​</a></h4><ol><li><p><strong>优先使用 Dockerfile</strong>：</p><ul><li>所有生产环境镜像必须通过 <code>Dockerfile</code> 构建，确保可审计性和一致性。</li><li>将 <code>Dockerfile</code> 纳入版本控制（如 Git）。</li></ul></li><li><p><strong>谨慎使用 docker commit</strong>：</p><ul><li>仅作为调试辅助工具，生成临时镜像后需及时清理。</li><li>若需长期使用 <code>docker commit</code> 生成的镜像，应反向生成 <code>Dockerfile</code>（如使用 <code>docker history</code> 分析）。</li></ul></li><li><p><strong>结合使用场景</strong>：</p><ul><li><strong>开发阶段</strong>：可用 <code>docker commit</code> 快速保存调试结果，但最终需将操作步骤转化为 <code>Dockerfile</code>。</li><li><strong>紧急修复</strong>：先用 <code>docker commit</code> 生成临时镜像，随后补充 <code>Dockerfile</code> 并重新构建。</li></ul></li></ol><hr><h4 id="扩展技巧" tabindex="-1"><strong>扩展技巧</strong> <a class="header-anchor" href="#扩展技巧" aria-label="Permalink to &quot;**扩展技巧**&quot;">​</a></h4><ul><li><p><strong>从容器反向生成 Dockerfile</strong>：<br> 使用工具（如 <code>docker history</code> 或第三方工具 <code>dfimage</code>）分析镜像层，尝试还原近似 <code>Dockerfile</code>：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -v</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /var/run/docker.sock:/var/run/docker.sock</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cucker/image-history</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> my-curl-image</span></span></code></pre></div></li><li><p><strong>清理临时镜像</strong>：<br> 定期清理通过 <code>docker commit</code> 生成的镜像，避免仓库臃肿：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> image</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> prune</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span></span></code></pre></div></li></ul><hr><p>通过合理选择 <code>Dockerfile</code> 和 <code>docker commit</code>，可以在效率与可维护性之间找到平衡，满足不同场景的需求。</p><h2 id="命令相关" tabindex="-1">命令相关 <a class="header-anchor" href="#命令相关" aria-label="Permalink to &quot;命令相关&quot;">​</a></h2><p>基础命令——docker searcher xxx、docker pull xxx、docker images xxx</p><h3 id="启动镜像" tabindex="-1">启动镜像： <a class="header-anchor" href="#启动镜像" aria-label="Permalink to &quot;启动镜像：&quot;">​</a></h3><p>启动镜像方法 <code>docker run -it(d) ImageId /bin/bash</code></p><h3 id="进入容器" tabindex="-1">进入容器： <a class="header-anchor" href="#进入容器" aria-label="Permalink to &quot;进入容器：&quot;">​</a></h3><p>docker exec -it ContainerId /bin/bash</p><p># docker exec#进入容器后开启一个新的终端，可以在里面操作（常用)</p><p># docker attach #进入容器正在执行的终端，不会启动新的进程!</p><h3 id="停止删除相关" tabindex="-1">停止删除相关： <a class="header-anchor" href="#停止删除相关" aria-label="Permalink to &quot;停止删除相关：&quot;">​</a></h3><p><code>docker stop ContainerId与docker start ContainerId </code> 停止/启动已有容器</p><p><code>docker rm ContainerId</code> 删除容器</p><p><code>docker rmi ImageId</code> 删除镜像</p><h3 id="其他" tabindex="-1">其他： <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他：&quot;">​</a></h3><p><code>docker run -d -p 8089:80 ImageId</code> 将指定镜像端口80映射到宿主机的8089上</p><p><code>docker cp /path/to/file container_id_or_name:/path/inside/container</code> 将宿主机文件复制到容器中</p><p><code>docker Images</code> 查询所有镜像</p><p><code>docker commit container_id_or_name new_image_name:tag</code> 提交保存当前镜像信息</p><p><code>docker ps -a</code> 查询所有容器、</p><p>查询服务状态可用systemctl、</p><p>docker inspect ContainerId查询具体容器信息</p><p>Docker的命令敲下运行之后，对应程序会开始工作比如寻找比如下载，其他的应用程序也估计差不多</p><p><strong>docker镜像、远程仓库(阿里云仓库)</strong></p><p><strong>docker login</strong> --username=aliyun2731059355 registry.cn-hangzhou.aliyuncs.com ——登录</p><p><strong>docker tag</strong> [ImageId] registry.cn-hangzhou.aliyuncs.com/wangyaofu/test1——准备上传标记</p><p><strong>docker push</strong> registry.cn-hangzhou.aliyuncs.com/wangyaofu/test1:——上传镜像</p><p><strong>docker pull</strong> registry.cn-hangzhou.aliyuncs.com/wangyaofu/test1:</p><p>——拉取镜像</p>',60)]))}const u=t(i,[["render",c]]);export{m as __pageData,u as default};
