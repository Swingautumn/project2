import{_ as t,c as a,o as r,ag as o}from"./chunks/framework.CQUK54pW.js";const u=JSON.parse('{"title":"K8SNote","description":"","frontmatter":{"title":"K8SNote","copyright_author":"王耀福","abbrlink":24884,"categories":["容器化技术","K8S"]},"headers":[],"relativePath":"Markdown/KubernetesNote.md","filePath":"Markdown/KubernetesNote.md"}'),n={name:"Markdown/KubernetesNote.md"};function s(l,e,d,i,p,c){return r(),a("div",null,e[0]||(e[0]=[o(`<h1 id="k8s-kubernetes" tabindex="-1">K8S(Kubernetes) <a class="header-anchor" href="#k8s-kubernetes" aria-label="Permalink to &quot;K8S(Kubernetes)&quot;">​</a></h1><p>Docker是容器化平台，提供容器的运行环境；K8s是容器编排系统/平台，管理多个Docker容器的部署、扩展、运行等。<strong>Docker负责打包和运行容器，而K8s则负责容器集群的自动化管理和编排</strong>。两者在现代应用部署和管理中通常结合使用，以构建稳定可靠且可扩展的容器化应用程序环境。</p><h2 id="基础理论" tabindex="-1">基础理论 <a class="header-anchor" href="#基础理论" aria-label="Permalink to &quot;基础理论&quot;">​</a></h2><p>Kunernetes(K8S)主要分成3部分：<strong>Master组件(APIs,scheduler,etc)，Node节点和cloud端</strong> Kubernetes（K8S）是一个复杂的系统，由多个组件协同工作来管理容器化应用程序。 K8S的组件大部分运行在master节点上，除了上面的APIs,scheduler,etc还有Controller Manager，工作节点上运行Kubelet、Container Runtime、Kube-proxy</p><h3 id="简略" tabindex="-1">(简略) <a class="header-anchor" href="#简略" aria-label="Permalink to &quot;(简略)&quot;">​</a></h3><p>APISERVER：所有服务访问统一入口 CrontrollerManager：维持副本期望数目 Scheduler：负责介绍任务，选择合适的节点进行分配任务 ETCD：键值对数据库储存K8S集群所有重要信息（持久化） Kubelet：直接跟容器引擎交互实现容器的生命周期管理 Kube-ProxY：负责写入规则至IPTABLES、IPVS 实现服务映射访问的 其他重要组件： COREDNS：可以为集群中的SVC创建一个域名IP的对应关系解析 DASHBOARDdashboard：给K8S集群提供一个B/S结构访问体系 Ingress Controller：官方只能实现四层代理，INGRESS可以实现七层代理 federation：提供一个可以跨集群中心多K8S统一管理功能 prometheus：提供K8S集群的监控能力 ELK：提供K8S集群日志统一分析介入平台</p><h3 id="详细" tabindex="-1">(详细) <a class="header-anchor" href="#详细" aria-label="Permalink to &quot;(详细)&quot;">​</a></h3><p>API Server 作用：作为 Kubernetes 的前端，提供 HTTP REST API 接口，用于与集群进行交互。所有对集群的请求（如创建、更新、删除资源）都通过 API Server 进行。 功能：验证请求、处理请求、更新集群状态、与 etcd 交互以存储和检索数据。</p><p>etcd(高可用必先处理的组件) 作用：分布式键值存储，用于存储集群的所有配置数据和状态信息。 功能：提供数据一致性、事件通知、健康检查和监控。使用 Raft 共识算法确保数据在多个节点之间的一致性。</p><p>Controller Manager 作用：运行多个控制器，这些控制器负责监管和维护集群的期望状态。 功能(5项)： Node Controller：管理节点的生命周期，检测节点的健康状态。 Deployment Controller：确保部署的Pod数量与期望状态一致。 ReplicaSet Controller：确保Pod副本数量与期望状态一致。 Endpoint Controller：管理 Service 和 Pod 之间的映射关系。 Service Account Controller：为 Pod 创建和管理服务账户。</p><p>Scheduler 作用：负责将新创建的 Pod 调度到合适的节点上运行。 功能：根据节点的资源可用性、Pod 的要求（如资源需求、亲和性规则）、以及集群的约束条件来选择最佳节点。</p><h2 id="踩坑指南" tabindex="-1">踩坑指南 <a class="header-anchor" href="#踩坑指南" aria-label="Permalink to &quot;踩坑指南&quot;">​</a></h2><p><a href="https://blog.csdn.net/weixin_43025151/article/details/135536233" target="_blank" rel="noreferrer">k8s重新初始化</a><a href="https://blog.csdn.net/m0_51720581/article/details/131153894" target="_blank" rel="noreferrer">k8s安装教程(注意k8s和docker版本)</a><a href="https://www.cnblogs.com/muzlei/p/16375178.html" target="_blank" rel="noreferrer">从节点8080端口访问拒绝解决办法</a><a href="https://blog.csdn.net/leenhem/article/details/119736586" target="_blank" rel="noreferrer">主节点kubectl get node命令报错,提示8080访问拒绝</a> kubetel工具启动报错可能跟swap系统有关 当k8s集群挂起重启后需要注意pod的状态，pod资源的访问以及故障转移大概要5分钟左右，也可以直接删除指定pod资源，集群会自动新建</p><h2 id="零散理论" tabindex="-1">零散理论 <a class="header-anchor" href="#零散理论" aria-label="Permalink to &quot;零散理论&quot;">​</a></h2><p>Kubernetes使用Pod来管理容器，<strong>每个Pod可以包含一个或多个紧密关联的容器，Pod是k8s的基本调度单位</strong>、容器体积小且启动快通过镜像可以在任何地方运行、Node是Pod真正运行的主机，可以是物理机，也可以是虚拟机。每个 Node 节点上至少要运行 container runtime（比如docker或者rkt）、kubelet和kube-proxy服务、Label是识别Kubernetes对象的标签，以key/value的方式附加到对象上、Annotations 是 key/value 形式附加于对象的注解。不同于 Labels 用于标志和选择对象，Annotations 用来记录一些附加信息，用来辅助应用部署、安全策略以及调度策略等 <strong>一个Pod包含多个容器，一个k8s集群往往也包含多个Pod</strong></p><p>在 Kubernetes（K8s）中，<strong>SVC 是 Service 的缩写</strong>。Service 是 Kubernetes 的核心组件之一，<strong>主要用于为 Pod 提供稳定的网络访问入口，并实现负载均衡和服务发现</strong>。</p><p>Pod控制器：RS、RC、Deployment、DaemonSet <strong>RC(Replication Controller)和RS(ReplicaSet)是两个用于管理 Pod 副本的核心控制器,Deployment 是更高层次的控制器，用于管理 ReplicaSet 和 Pod 的部署过程</strong> ReplicaSet 是 RC 的升级版，提供更灵活的标签选择机制，且与 Deployment 深度集成。 ReplicaSet 是 Deployment 的底层实现，用于支持滚动更新和版本回滚 在大多数场景中，应通过 Deployment 管理 ReplicaSet，而不是手动创建/修改 ReplicaSet。 无状态服务Apache...，docker适合；有状态服务mysql...，K8S(的<strong>statefulset技术</strong>)适合</p><table tabindex="0"><thead><tr><th><strong>控制器</strong></th><th><strong>核心定位</strong></th><th><strong>与 DaemonSet 的关系</strong></th></tr></thead><tbody><tr><td><strong>RC/RS</strong></td><td>副本数量维护</td><td>与 DaemonSet 互补，分别管理全局副本和节点级副本。</td></tr><tr><td><strong>Deployment</strong></td><td>应用生命周期管理</td><td>通过 ReplicaSet 间接控制 Pod，与 DaemonSet 协同支持全栈需求。</td></tr><tr><td><strong>DaemonSet</strong></td><td>节点级任务管理</td><td>独立于其他控制器，专注于节点维度的 Pod 部署。</td></tr></tbody></table><h2 id="k8s命令相关" tabindex="-1">K8S命令相关 <a class="header-anchor" href="#k8s命令相关" aria-label="Permalink to &quot;K8S命令相关&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kubeadm init --apiserver-advertise-address=192.168.40.21 --image-repository registry.aliyuncs.com/google_containers --service-cidr=10.1.0.0/16 --pod-network-cidr=10.244.0.0/16 k8s节点初始化</span></span>
<span class="line"><span>kubeadm token list 查看token列表以及token剩余时间</span></span>
<span class="line"><span>kubeadm token create --print-join-command 重新生成token</span></span>
<span class="line"><span>kubectl get node 查看所有节点目前状态及信息</span></span>
<span class="line"><span>kubectl get pod 查看所有pod目前状态及信息</span></span>
<span class="line"><span>kubectl delete pod &lt;pod-name&gt; 删除指定pod资源</span></span></code></pre></div>`,20)]))}const b=t(n,[["render",s]]);export{u as __pageData,b as default};
